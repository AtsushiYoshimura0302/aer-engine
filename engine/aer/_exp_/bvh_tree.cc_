// -----------------------------------------------------------------------------
// CreativeCommons BY-SA 3.0 2013 <Thibault Coppex>
//
//
// -----------------------------------------------------------------------------


#include "aer/rendering/bvh_tree.h"


namespace aer {

BVHTree::BVHTree() :
  numnodes_(0u),
  numleaves_(0u),
  meshes_(nullptr),
  bboxes_(nullptr)
{
  tree_.clear();
  attribs_.clear();
}

void BVHTree::build(U32 nelems,
                    const Mesh *meshes,
                    const BoundingBox *bboxes) {
  numleaves_ = nelems;
  numnodes_  = 2u * nelems + - 1u;
  meshes_ = meshes; //
  bboxes_ = bboxes; //
  
  tree_.resize(numnodes_);
  attribs_.resize(numnodes_);  
  
  init();

  /// Shared buffer of U32 used to build the tree
  build_buffer_ui_.resize(5u * numleaves_);

  /// Maps common buffers used during the build
  BuildParams params(&build_buffer_ui_[0u*numleaves_],  // sorted X
                     &build_buffer_ui_[1u*numleaves_],  // sorted Y
                     &build_buffer_ui_[2u*numleaves_],  // sorted Z
                     &build_buffer_ui_[3u*numleaves_],  // resort LUT
                     &build_buffer_ui_[4u*numleaves_]); // resort buffer

  /// Sort objects' AABBs per axis
  sortAABBs(params);

  U32 counter = 0u;
  subBuild(params, 0u, 0u, 0u, numleaves_, &counter);
}


void BVHTree::sortAABBs(BuildParams_t &params) {
  std::vector<Vector3> buffer(numleaves_);
  for (U32 i = 0u; i < buffer.size(); ++i) {
    buffer[i] = bboxes_[i].center();
  }

  F32 *fdatas = reinterpret_cast<F32*>(buffer.data());

  IndexSorter isorter;
  isorter.sortX(numleaves_, fdatas, params.sorted_indices[0]);
  isorter.sortY(numleaves_, fdatas, params.sorted_indices[1]);
  isorter.sortZ(numleaves_, fdatas, params.sorted_indices[2]);
}

void BVHTree::debug_display(const Vector4 planes[Frustum::kNumPlane],
                            BVHNode *node, 
                            U32 depth)
{
  if (nullptr == node) {
    debug_display(planes, &m_tree[0u]);
    return;
  }

  // Frustum culling
  if (!inside_view_frustum(node->id(), planes)) {
   return;
  }


  Vector3 color;
  if (!node->is_leaf()) {
    U32 offset = node->offset();
    debug_display(planes, &m_tree[offset],      depth + 1u);
    debug_display(planes, &m_tree[offset + 1u], depth + 1u);

    F32 c = depth / log2f(numleaves_);
    color = Vector3(0.2f, 0.45f*c + 0.2f, 0.9f*c + 0.01f);
  } else {
    color = Vector3(0.95f, 0.45f, 0.31f);
  }

  const Vector3 &pos     = attribs_[node->id()].bbox.center();
  const Vector3 &scaling = attribs_[node->id()].bbox.scaling();

  //DebugDrawer.add_cube(pos, scaling, color);
}



void BVHTree::subBuild(const BuildParams_t &params, 
                       U32 node_id,
                       U32 parent_id,
                       U32 offset,
                       U32 count,
                       U32 *counter_ptr)
{
  BVHNode &node = tree_[node_id];

  /// Compute node's AABB
  BoundingBox &bbox = attribs_[node_id].bbox;
  {
    U32 *indices = &(params.sorted_indices[0u][offset]);

    bbox = BoundingBox(bboxes_[indices[0u]]); //
    for (U32 i = 1u; i < count; ++i) {
      bbox.add_aabb(bboxes_[indices[i]]);
    }
  }

  /// Finish when a leaf is reached
  if (count <= 1u) {
    U32 bbox_id = params.sorted_indices[0u][offset];
    node.set(node_id, parent_id, bbox_id, true);
    return;
  }

  /// Find Best cost for the Surface Area Heuristic (along the 3 axis)
  F32 best_cost = FLT_MAX;
  U32 best_id   = 0u;
  U8  best_axis = 0;
    
  for (U8 axis = 0; axis < 3; ++axis) {
    if (find_best_sa_cost(params, offset, count, axis, &best_cost, &best_id)) {
      best_axis = axis;
    }
  }

  /// Resort others axis (left & right subset)
  if (best_axis != 0) resort(params, offset, count, best_axis, 0, best_id);
  if (best_axis != 1) resort(params, offset, count, best_axis, 1, best_id);
  if (best_axis != 2) resort(params, offset, count, best_axis, 2, best_id);

  /// Continue recursively  
  U32 left_offset  = offset;
  U32 left_count   = best_id;
  U32 right_offset = left_offset + left_count;
  U32 right_count  = count - left_count;

  U32 left_id  = (*counter_ptr) + 1u;
  U32 right_id = (*counter_ptr) + 2u;
  *counter_ptr = right_id;

  node.set(node_id, parent_id, left_id, false);
  subBuild(params,  left_id, node_id,  left_offset,  left_count, counter_ptr);
  subBuild(params, right_id, node_id, right_offset, right_count, counter_ptr);
}

bool BVHTree::find_best_sa_cost(const BuildParams_t &params, 
                                U32 offset, 
                                U32 count, 
                                U8 axis, 
                                F32 *bestcost_ptr,
                                U32 *bestid_ptr)
{
  const U32 *indices = &(params.sorted_indices[axis][offset]);
  bool bNewBest = false;

  /// Left bounding box
  BoundingBox left_box(bboxes_[indices[0u]]);

  /// Right bounding boxes stored 'right to left'
  const U32 nRightBoxes = count - 1u;
  std::vector<BoundingBox> right_boxes(nRightBoxes); // TODO : put outside [XXX]
  right_boxes[0u] = bboxes_[indices[nRightBoxes]];

  /// Right boxes are precomputed to be in linear time
  for (U32 i = 1u; i < nRightBoxes; ++i) {
    right_boxes[i] = BoundingBox(right_boxes[i-1u]);

    const U32 idx = indices[nRightBoxes - i];
    right_boxes[i].add_aabb(bboxes_[idx]);
  }

  // [Unused] current box surface area to ponderate the cost
  //const F32 invSA = 1.0f / bbox.surface_area();

  /// Search minimal cost
  for (U32 i = 1u; i < count; ++i) {
    F32 lSA = left_box.surface_area();
    F32 rSA = right_boxes[nRightBoxes - i].surface_area();

    // Compute Surface Area cost
    F32 cost = i * lSA + (count-i) * rSA; //   + glm::max(lSA,rSA)

    if (cost < *bestcost_ptr) {
      *bestcost_ptr = cost;
      *bestid_ptr   = i;
      bNewBest      = true;
    }

    // update left Bbox
    left_box.add_aabb(bboxes_[indices[i]]);
  }

  return bNewBest;
}

void BVHTree::resort(const BuildParams_t &params,
                     U32 offset,
                     U32 count,
                     U32 split_id,
                     U8 base_axis,
                     U8 axis)
{
  U32 *base_indices = &(params.sorted_indices[base_axis][offset]);
  U32 *dst_indices  = &(params.sorted_indices[axis][offset]);
  U32 *LUT          = params.lut_ptr;
  U32 *resort_buffer = params.resort_ptr;

  /// Fill the LUT (partially)
  for (U32 i = 0u; i < count; ++i) {
    LUT[base_indices[i]] = i;
  }

  /// Resort left & right subset
  U32 left_id  = 0u;
  U32 right_id = split_id;
    
  /// Resort in linear time
  for (U32 i = 0u; i < count; ++i) {
    U32 idx = dst_indices[i];

    if (LUT[idx] < split_id) {
      resort_buffer[left_id++] = idx;
    } else {
      resort_buffer[right_id++] = idx;
    }
  }

  std::copy(resort_buffer, &resort_buffer[count], dst_indices);
}

} // aer
