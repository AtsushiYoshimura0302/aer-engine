

It could be interesting to set Shader as a struct object and don't make it
herit from DeviceResource.

Put the Shader Compiler/Loader in a ResourceProxy-like structure, which handle
shader reference mangement / source update listener / recompilation.

A Program object could be a DeviceResource or be manage like shaders.

Note that programs can be created directly from binary or from a single shader
(making it separable for that stage, to append to a program pipeline)


When a program use a shader :
  A structure handle the Program references per shader
  -- OR --
  The program check periodically the Shaders structure to see if its hash change



ShadersProxy &shadersProxy = ShadersProxy::Get();
program.add_shader(shadersProxy.get("shaders_path_name"))

//

shaderFactory.create_shader(GL_VERTEX_SHADER, name);

//

ProgramManager::Get().register(program);

//---------

The engine holds two global sets :
  - a set of shaders
  - a set of programs

Each frame :
  1- for each shaders, if file updated :
      - recompile, 
      - set status to UPDATED
  
  2- for each program:
      - for each linked shaders, if UPDATED : 
          -set Program status to DIRTY or relink
  
  3- for each shaders, set status to DEFAULT

//---------

3 ways of creating a program :
  - successive call to add_shader_source() / add_shader_binary(), then link()
  - create from one shader using create_program(shadername)
  - load complete program binary

it is :
  - glShaderSource + glCompileShader/ glShaderBinary, glAttachShader, glLinkProgram
  - glCreateShaderProgramv
  - glProgramBinary

//---------


// !! Important !!
When the ShaderLoader return a reference, it increments its counter
When a program detach a shader, the ShaderLoader decrements its counter

-> this is already perform by ResourceProxy !!


//--------

Does ShaderLoader detect the shader type or do we need to specify it ?

//

Let the user pass shader source to the ShaderLoader (/ Manager)

Some shader could keep their source / alternatively, create a ShaderSource object

it could be useful for say, ComputeShader, with DEFINEs to changes

-------------------------------------------------------------------------------

  1 - Shader

      -> Loaded from source or binary
      -> Represents a complete-or-not portion of a STAGE..
      -> ..thus being potentially an INCLUDE file
      -> Used by 1-to-n programs
      -> hook available to reload it when change

  >>  Mostly not viewed by the user, which interact mainly only with the ShaderLoader.
      The ShaderLoader return a simple const reference to the program.



  2 - Program

      -> A set of linked shaders or a single one..
      -> ..which can also be loaded from a program binary
      -> Represent a set of 1-to-n STAGEs
      -> Have to relink when shaders updated or parameters changes
      -> Update uniform with glUniform* when binded..
      -> ..or glProgramUniform* anytime
      -> handle subroutine uniforms

  >> First things first, let's say a Program is construct manually (as done actually)
      from shaders, themselves loaded via a manager / proxy


  3 - Pipeline

      -> A set of separable program
      -> each representing a set of non-conflicting STAGE
      -> specify active programs with glUseProgramStages
      -> activate pipeline with glBindProgramPipeline..
      -> ..which works when no programs is in used (glUseProgram(0u))

  >> Pipeline could be a generic DeviceResource, but nothing force to use them.
     Uniforms are still change by the Program object, which are visible to the
     user (a priori).

